{"componentChunkName":"component---src-templates-blog-post-js","path":"/Spring/bean-injection-하는-방법에-대하여/","result":{"data":{"site":{"siteMetadata":{"title":"white-gyu Logs","author":"white-gyu","siteUrl":"https://white-gyu.github.io","sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"3aa5b80a-7cb6-590c-a81d-878e4c8f9dab","excerpt":"1. DI 방법 생성자 기반 주입 컨테이너가 알아서 생성자에게 객체를 넣어주면서 생성하게 됩니다. 생성자의 파라미터를 통해 의존 관계를 파악하기 쉽다는 장점이 존재합니다. 롬복의 도움으로 아래와 같이 코드를 줄일 수 있습니다. Setter 기반 주입 인수가 없는 생성자를 호출한 후 빈에서 setter…","html":"<h2 id=\"1-di-방법\" style=\"position:relative;\"><a href=\"#1-di-%EB%B0%A9%EB%B2%95\" aria-label=\"1 di 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. DI 방법</h2>\n<h3 id=\"생성자-기반-주입\" style=\"position:relative;\"><a href=\"#%EC%83%9D%EC%84%B1%EC%9E%90-%EA%B8%B0%EB%B0%98-%EC%A3%BC%EC%9E%85\" aria-label=\"생성자 기반 주입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>생성자 기반 주입</h3>\n<p>컨테이너가 알아서 생성자에게 객체를 넣어주면서 생성하게 됩니다. 생성자의 파라미터를 통해 의존 관계를 파악하기 쉽다는 장점이 존재합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StudentController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">StudentService</span> studentService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">StudentController</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StudentService</span> studentService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>studentService <span class=\"token operator\">=</span> studentService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>롬복의 도움으로 아래와 같이 코드를 줄일 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StudentController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">StudentService</span> studentService<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"setter-기반-주입\" style=\"position:relative;\"><a href=\"#setter-%EA%B8%B0%EB%B0%98-%EC%A3%BC%EC%9E%85\" aria-label=\"setter 기반 주입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Setter 기반 주입</h3>\n<p>인수가 없는 생성자를 호출한 후 빈에서 setter를 호출해 주입하는 방식입니다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StudentController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">StudentService</span> studentService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setStudentService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StudentService</span> studentService<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>studentService <span class=\"token operator\">=</span> studentService<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"필드-주입\" style=\"position:relative;\"><a href=\"#%ED%95%84%EB%93%9C-%EC%A3%BC%EC%9E%85\" aria-label=\"필드 주입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>필드 주입</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StudentController</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">StudentService</span> studentService<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>필드 주입은 <span style=\"color: #bf2a2a;font-weight: bold\">외부에서 변경이 불가능하다는 단점</span>이 존재하는데, 점차 테스트 코드의 중요성이 부각됨에 따라 <span style=\"color: #bf2a2a;font-weight: bold\">필드의 객체를 수정할 수 없는 필드 주입</span>은 거의 사용되지 않게 되었습니다.\n또한 <strong>필드 주입은 반드시 DI 프레임워크가 존재</strong>해야 하므로 반드시 사용을 지양해야 합니다. 그렇기에 애플리케이션의 실제 코드와 무관한 테스트 코드나 설정을 위해 불가피한 경우에만 이용하도록 해야겠네요.</p>\n<br>\n<h2 id=\"2-생성자-기반-주입-방법을-지양하자\" style=\"position:relative;\"><a href=\"#2-%EC%83%9D%EC%84%B1%EC%9E%90-%EA%B8%B0%EB%B0%98-%EC%A3%BC%EC%9E%85-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%98%EC%9E%90\" aria-label=\"2 생성자 기반 주입 방법을 지양하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 생성자 기반 주입 방법을 지양하자</h2>\n<p>최근에는 인텔리제이에서도 그렇고 @Autowired 어노테이션을 이용한 필드 주입보다 생성자 기반 주입을 권합니다. 왜 인텔리제이에서도 그렇게 권장할까요?</p>\n<h3 id=\"객체의-불변성-확보\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B6%88%EB%B3%80%EC%84%B1-%ED%99%95%EB%B3%B4\" aria-label=\"객체의 불변성 확보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체의 불변성 확보</h3>\n<p>실제로 개발을 하다 보면 느끼겠지만, <span style=\"color: #bf2a2a; font-weight: bold\">의존 관계 주입의 변경이 필요한 상황은 거의 없습니다</span>. 하지만 수정자 주입이나 일반 메소드 주입을 이용하면 불필요하게 수정의 가능성을 열어두게 되며, 이는 OOP의 5가지 개발 원칙 중 OCP(Open-Closed Principal, 개방-폐쇄의 법칙)를 위반하게 됩니다. 그러므로 <span style=\"color: rgb(0 30 181 / 85%); font-weight: bold\">생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장</span>하는 것이 좋습니다.</p>\n<h3 id=\"테스트-코드-작성\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1\" aria-label=\"테스트 코드 작성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 코드 작성</h3>\n<p>실제 코드가 <span style=\"color: #bf2a2a; font-weight: bold\">필드 주입으로 작성된 경우에는 순수한 자바 코드로 단위 테스트를 작성하는 것이 불가능</span>합니다. 물론, ReflectionTestUtilsf를 사용해 주입해줄 수 있기는 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UserService</span> <span class=\"token punctuation\">{</span> \n    \n    <span class=\"token annotation punctuation\">@Autowired</span> \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserRepository</span> userRepository<span class=\"token punctuation\">;</span> \n    \n    <span class=\"token annotation punctuation\">@Autowired</span> \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MemberService</span> memberService<span class=\"token punctuation\">;</span> \n    \n    <span class=\"token annotation punctuation\">@Override</span> \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        userRepository<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceTest</span> <span class=\"token punctuation\">{</span> \n    \n    <span class=\"token annotation punctuation\">@Test</span> \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token class-name\">UserService</span> userService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UserServiceImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n        \n        userService<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"whiteGyu\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 작성한 <span style=\"color: #bf2a2a; font-weight: bold\">테스트 코드는 Spring과 같은 DI 프레임워크 위에서 동작하지 않으므로 의존 관계 주입이 되지 않습니다</span>.\nuserRepository가 null이 되어 userRepository의 add 호출 시 NPE가 발생합니다. 이를 해결하기 위해 <span style=\"color: #bf2a2a; font-weight: bold\">Setter를 사용하면 여러 곳에서 사용가능한 싱글톤 패턴 기반의 빈이 변경될 수 있는 치명적인 단점</span>을 갖게 됩니다. 또한 반대로 테스트 코드에서도 @Autowired를 사용하기 위해 스프링 빈을 올리면 단위 테스트가 아니며 컴포넌트들을 등록하고 초기화하는 시간이 커져 테스트 비용이 증가하게 됩니다.</p>\n<p>반면에 <span style=\"color: rgb(0 30 181 / 85%); font-weight: bold\">생성자 주입을 사용하면 컴파일 시점에 객체를 주입받아 테스트 코드를 작성할 수 있으며, 주입하는 객체가 누락된 경우 컴파일 시점에 오류를 발견</span>할 수 있습니다.\n심지어 우리가 테스트를 위해 만든 Test객체를 생성자로 넣어 편리함을 얻을 수도 있습니다.</p>\n<h3 id=\"final-선언-가능\" style=\"position:relative;\"><a href=\"#final-%EC%84%A0%EC%96%B8-%EA%B0%80%EB%8A%A5\" aria-label=\"final 선언 가능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>final 선언 가능</h3>\n<p>생성자 주입을 사용하면 필드 객체에 final 키워드를 사용할 수 있으며, 컴파일 시점에 누락된 의존성을 확인할 수 있습니다. 반면에 생성자 주입을 제외한 다른 주입 방법들은 객체의 생성(생성자 호출) 이후에 호출되므로 final 키워드를 사용할 수 없습니다.</p>\n<h3 id=\"순환-참조-에러-방지\" style=\"position:relative;\"><a href=\"#%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0-%EC%97%90%EB%9F%AC-%EB%B0%A9%EC%A7%80\" aria-label=\"순환 참조 에러 방지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순환 참조 에러 방지</h3>\n<p>애플리케이션 구동 시점(객체의 생성 시점)에 순환 참조 에러를 방지할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UserService</span> <span class=\"token punctuation\">{</span> \n    \n    <span class=\"token annotation punctuation\">@Autowired</span> \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MemberServiceImpl</span> memberService<span class=\"token punctuation\">;</span> \n    \n    <span class=\"token annotation punctuation\">@Override</span> \n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n        memberService<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MemberServiceImpl</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">MemberService</span> <span class=\"token punctuation\">{</span> \n\n    <span class=\"token annotation punctuation\">@Autowired</span> \n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">UserServiceImpl</span> userService<span class=\"token punctuation\">;</span> \n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> \n        userService<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 두 메소드는 서로를 계속 호출할 것이고, 메모리에 함수의 CallStack이 계속 쌓여 StackOverflow 에러가 발생하게 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">Caused by: java.lang.StackOverflowError: null \n        at com.mang.example.user.MemberServiceImpl.add<span class=\"token punctuation\">(</span>MemberServiceImpl.java:20<span class=\"token punctuation\">)</span> ~<span class=\"token punctuation\">[</span>main/:na<span class=\"token punctuation\">]</span> \n        at com.mang.example.user.UserServiceImpl.register<span class=\"token punctuation\">(</span>UserServiceImpl.java:14<span class=\"token punctuation\">)</span> ~<span class=\"token punctuation\">[</span>main/:na<span class=\"token punctuation\">]</span> \n        at com.mang.example.user.MemberServiceImpl.add<span class=\"token punctuation\">(</span>MemberServiceImpl.java:20<span class=\"token punctuation\">)</span> ~<span class=\"token punctuation\">[</span>main/:na<span class=\"token punctuation\">]</span> \n        at com.mang.example.user.UserServiceImpl.register<span class=\"token punctuation\">(</span>UserServiceImpl.java:14<span class=\"token punctuation\">)</span> ~<span class=\"token punctuation\">[</span>main/:na<span class=\"token punctuation\">]</span></code></pre></div>\n<p>만약 이러한 문제를 발견하지 못하고 서버가 운영된다면 어떻게 될까요? 해당 메소드의 호출 시에 StackOverflow 에러에 의해 서버가 죽게 될 것입니다. 하지만 생성자 주입을 이용하면 이러한 순환 참조 문제를 방지할 수 있습니다.\n<strong>애플리케이션 구동 시점(객체의 생성 시점)에 에러가 발생</strong>하기 때문입니다. 그러한 이유는 <strong>Bean에 등록하기 위해 객체를 생성하는 과정에서 다음과 같이 순환 참조가 발생</strong>하기 때문입니다.</p>\n<p>요약하자면 아래와 같습니다.</p>\n<blockquote>\n<ul>\n<li>객체의 불변성을 확보 가능</li>\n<li>테스트 코드의 작성 용이</li>\n<li>final 키워드 및 Lombok과의 결합을 통해 코드를 간결하게 작성 가능</li>\n<li>순환 참조 문제를 를 애플리케이션 구동(객체의 생성) 시점에 파악하여 방지 가능</li>\n</ul>\n</blockquote>\n<p>이러한 이유들로 DI 프레임워크를 사용하는 경우, <strong>생성자 주입</strong> 을 권장합니다.</p>\n<br>\n<h2 id=\"3-왜-굳이-인터페이스를-bean으로-주입할까\" style=\"position:relative;\"><a href=\"#3-%EC%99%9C-%EA%B5%B3%EC%9D%B4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-bean%EC%9C%BC%EB%A1%9C-%EC%A3%BC%EC%9E%85%ED%95%A0%EA%B9%8C\" aria-label=\"3 왜 굳이 인터페이스를 bean으로 주입할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 왜 굳이 인터페이스를 Bean으로 주입할까?</h2>\n<p>Spring에서 보통 인터페이스를 선언하고 @Service를 사용해서 빈 주입을 합니다. 구현체가 아니라 왜 인터페이스를 통해서 빈을 주입하는지에 대해 의문점이 생겼습니다.\n제가 이해한 바로는 2가지 이유가 있네요.</p>\n<h3 id=\"spring-proxy\" style=\"position:relative;\"><a href=\"#spring-proxy\" aria-label=\"spring proxy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>spring proxy</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">MyService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyServiceImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">MyService</span> <span class=\"token punctuation\">{</span>\n    \n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello Im Impl Service\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyController</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// 인터페이스 타입</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">MyService</span> myService<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 클래스 타입</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">MyServiceImpl</span> myServiceImpl<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">spring<span class=\"token punctuation\">.</span>aop<span class=\"token punctuation\">.</span>proxy<span class=\"token operator\">-</span>target<span class=\"token operator\">-</span><span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token boolean\">false</span> </code></pre></div>\n<p><strong>인터페이스 타입</strong></p>\n<blockquote>\n<p>구현 상속 관계 : MyService -> MyServiceImpl\n프록시 상속 관계 : MyService -> ProxyMyService </p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">spring<span class=\"token punctuation\">.</span>aop<span class=\"token punctuation\">.</span>proxy<span class=\"token operator\">-</span>target<span class=\"token operator\">-</span><span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token boolean\">true</span></code></pre></div>\n<p><strong>클래스 타입</strong></p>\n<blockquote>\n<p>구현 상속 관계 : MyService -> MyServiceImpl\n프록시 상속 관계 : MyServiceImpl -> ProxyMyService\nMyService —> MyServiceImpl —> ProxyMyService</p>\n</blockquote>\n<p>이 경우 스프링이 생성하는 프록시가 MyServiceImpl을 부모로 하여 생성하는 프록시가 됩니다.</p>\n<p>요약하자면 아래와 같습니다.</p>\n<blockquote>\n<ul>\n<li>\n<p>스프링 프록시 설정이 <span style=\"color: rgb(0 30 181 / 85%); font-weight: bold\">True</span>인 경우 </p>\n<ul>\n<li>인터페이스 타입 &#x26; 클래스 타입 빈 주입 가능</li>\n<li>\n<p>아래의 상황에선 에러 발생 </p>\n<ul>\n<li>사용자가 Service class를 final로 선언 -> 상속 불가능</li>\n<li>private 생성자 선언</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>스프링 프록시 설정이 <span style=\"color: #bf2a2a; font-weight: bold\">False</span>인 경우 </p>\n<ul>\n<li>인터페이스 타입만 빈 주입 가능 (클래스 타입 빈 주입 X)</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"oop-개방-폐쇄-원칙\" style=\"position:relative;\"><a href=\"#oop-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"oop 개방 폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OOP 개방 폐쇄 원칙</h3>\n<blockquote>\n<p>개방 폐쇄의 원칙이란, 확장에는 열려있고 변화에는 닫혀있다는 의미</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/67765871/160088066-af02037f-c189-4748-b45a-7fdefa88e22e.png\" alt=\"컨트롤러 및 서비스 빈 주입\"></p>\n<p>서비스 클래스가 인터페이스를 구현하고 있다면 코드 상에서 컨트롤러는 인터페이스만을 바라보고 있습니다. <strong>실제 구현 클래스는 런타임 시점까지 알지 못하는 상태</strong>입니다.</p>\n<p>컨트롤러 입장에서는 서비스 클래스의 비즈니스 로직에 대해서는 관심이 없습니다. 그냥 인터페이스에 있는 메소드를 이용해 로직을 구성할 뿐이기 때문에 <strong>서비스 클래스의 내부 로직이 어떻게 변하던 영향을 받지 않습니다</strong>. <strong>즉, 변화에 닫혀 있습니다.</strong></p>\n<p>반대로 서비스 클래스는 인터페이스에서 규정된 규칙만 잘 지키면 언제든 로직을 변경할 수도 있고, 인터페이스를 구현한 새로운 클래스를 하나 만들어서 기존 클래스를 대체할 수도 있습니다. 확장에는 열려있다라고 표현합니다.</p>\n<p>결론적으로, 인터페이스가 아니라 <strong>클래스 타입으로 빈을 주입한다면 개방 폐쇄 원칙에 위배되므로 인터페이스 타입으로 빈을 주입하는 방향이 좋다</strong>고 생각합니다.</p>\n<br>\n<h2 id=\"4-참고-자료\" style=\"position:relative;\"><a href=\"#4-%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"4 참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 참고 자료</h2>\n<p><a href=\"https://mangkyu.tistory.com/125\">[Spring] 다양한 의존성 주입 방법과 생성자 주입을 사용해야 하는 이유 - (2/2)</a></p>\n<p><a href=\"https://jyami.tistory.com/72\">인터페이스 빈주입을 사용하는 이유</a></p>\n<p><a href=\"https://codevang.tistory.com/312\">스프링 의존 주입(DI)과 인터페이스 사용에 관하여</a></p>","frontmatter":{"title":"Bean Injection 하는 방법에 대하여","date":"January 15, 2022"}}},"pageContext":{"slug":"/Spring/bean-injection-하는-방법에-대하여/","previous":{"fields":{"slug":"/HTTP/query-parameter-vs-path-variable/"},"frontmatter":{"title":"Query Parameter vs Path Variable"}},"next":{"fields":{"slug":"/JPA/getbyid-vs-findbyid/"},"frontmatter":{"title":"getById vs findById"}}}},"staticQueryHashes":["2486386679","3128451518"]}